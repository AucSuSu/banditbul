#  포팅 메뉴얼 

# 개요

## 1. 프로젝트 사용 도구

- 이슈 관리 : JIRA
- 형상 관리 : Gitlab, Gerrit
- 커뮤니케이션 : Notion, Mattermost
- 디자인 : Figma
- UCC : 모바비
- CI/CD : Jenkins, Docker


## 2. 사용 프로그램 버전

- VS Code: 1.85.1
- Spring Boot: 2.7.13
- Gradle: 8.5
- JVM: 17
- IntelliJ: 23.3.2
- Node.js: 20.10.0
- React: 18.02
- SERVER: AWS EC2 Ubuntu 20.04.3 LTS
- DB: PostgreSQL

## 3. 외부 서비스
- 없음



## 설치하기
### 서버 M
1. docker를 설치합니다. 
    ```
        $ sudo apt-get update //우분투 시스템 패키지 업데이트

        $ sudo apt-get install \
            ca-certificates \
            curl \
            gnupg \
            lsb-release
    ```  
    - https 관련 패키지 설치
    ```
        $ sudo apt install apt-transport-https ca-certificates curl software-properties-common
    ```
    - Docker의 공식 GPG키 추가(docker repository 접근을 위한)
    ```
        $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
    ```
    - docker repository 등록
    ```
        $ sudo add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu focal stable"
    ```
    - docker 설치
    ```
        $ sudo apt-get install docker-ce docker-ce-cli containerd.io
    ```


2. 인증서를 발급합니다. 
    ```
        $ sudo apt update
        $ sudo apt-get install letsencrypt -y
    ```
    ```
        $ sudo apt-get update
        $ sudo apt-get install certbot python3-certbot-nginx
        $ sudo snap install certbot --classic
        $ sudo certbot --nginx -d [도메인]
    ```
   - 이메일 입력 (필수)
   - 서비스 약관 동의 Y
  
3. nginx를 설치합니다. 
    ```
        $ sudo apt-get install nginx
    ```

4. 젠킨스를 설치합니다.
    ```
        $ docker pull jenkins/jenkins:lts
    ```
    - Jenkins 띄우기
    ```
        $ sudo docker run -d --name jenkins -p 8080:8080 jenkins/jenkins:jdk17 //숫자는 버전
    ```


### 서버 T 
1. Redis를 설치합니다. 
   ```
   # redis 이미지 받아오기 
   $ docker pull redis 

   # docker로 실행시키기 (포트 6379번)
   $ docker run --name redis -d -p 6379:6379 redis 
   ```
  
## 빌드
### 1. Front
	npm i
	npm run dev
### 2. Back-spring
	Gradle 실행
	Bootjar 실행

  
## 환경 설정 하기 
1. /etc/nginx/conf.d/include/default.template 파일을 작성합니다.
        
    ```
        server {
            listen 80;
            listen [::]:80;
            server_name banditbul.co.kr;

            # 모든 HTTP 요청을 HTTPS로 리다이렉트
            return 301 https://$server_name$request_uri;
        }

        server {
            listen 443 ssl;
            listen [::]:443 ssl ipv6only=on;

            server_name banditbul.co.kr;

            # API 요청을 처리하기 위한 리버스 프록시 설정
            location /api {
                proxy_pass http://k10e102.p.ssafy.io:${port};
                #proxy_pass http://k10e102.p.ssafy.io:8080;
                proxy_http_version 1.1;
                proxy_set_header Upgrade $http_upgrade;
                proxy_set_header Connection 'upgrade';
                proxy_set_header Host $host;
                proxy_cache_bypass $http_upgrade;
                proxy_set_header X-Real-IP $remote_addr;
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                proxy_set_header X-Forwarded-Proto $scheme;
            }

            location /socket {
                add_header 'Access-Control-Allow-Origin' '*'; #모든 도메인 허용
                proxy_pass http://k10e102.p.ssafy.io:${port};
                #proxy_pass http://k10e102.p.ssafy.io:8080;
                proxy_http_version 1.1;
                proxy_set_header Upgrade $http_upgrade;
                proxy_set_header Connection "upgrade";
                proxy_read_timeout 3600s; #60분으로 연장
            }

            # 기본 파일 요청 처리
            location / {
                root /home/ubuntu/dist;
                index index.html index.htm index.nginx-debian.html;
                try_files $uri /index.html;
            }

            ssl_certificate /etc/letsencrypt/live/banditbul.co.kr/fullchain.pem;
            ssl_certificate_key /etc/letsencrypt/live/banditbul.co.kr/privkey.pem;
            include /etc/letsencrypt/options-ssl-nginx.conf;
            ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;
        }
    ```


    ```
        $ sudo rm -f /etc/nginx/sites-enabled/default
        $ export port=8080;
        $ sudo -E envsubst ${port} < /etc/nginx/conf.d/include/default.template | sudo tee /etc/nginx/sites-enabled/default > /dev/null
        $ sudo nginx -t && sudo nginx -s reload
    ```
    
2. application.yml
 
    ```
        spring:
        application:
            name: bandi

        datasource:
            url: jdbc:postgresql://db-bandi.cpc4uswu8hst.ap-northeast-2.rds.amazonaws.com:5432/postgres
            username: postgres
            password: byeoljalie102
            driver-class-name: org.postgresql.Driver

        data:
            redis:
            host: 3.35.115.111
            port: 6379
            password: 'strongPassword'

        session:
            redis:
            namespace: custom:session

        jpa:
            show-sql: true
            database: POSTGRESQL
            database-platform: org.hibernate.dialect.PostgreSQLDialect
            properties:
            hibernate:
                dialect: org.hibernate.dialect.PostgreSQLDialect
            hibernate:
            ddl-auto: update

    ```



## Jenkins Pipeline 

Git Branch 전략으로 master, front, back으로 각 branch를 구분하여 webhook을 걸어 각 branch에서 push 될 때마다 각 jenkins pipeline이 동작하도록 했다.

### Back
```
pipeline {
    agent any
    options { skipDefaultCheckout(false) }
    stages {
        stage('Initialize Port') {
            steps {
                script {
                    sshagent(['aws']) {
                        script {
                            env.DEPLOY_PORT = sh(script: '''
                                ssh -o StrictHostKeyChecking=no ubuntu@banditbul.co.kr "cat /etc/nginx/conf.d/include/port.conf | grep 'set \\$port' | cut -d ' ' -f3 | tr -d ';'"
                            ''', returnStdout: true).trim()
                            echo "Fetched port: ${env.DEPLOY_PORT}"
                        }
                    }
                }
            }
        }

        stage('Determine New Port') {
            steps {
                script {
                    // 포트 번호 전환 로직
                    echo "The origin port: ${env.DEPLOY_PORT}"
                    env.NEW_PORT = (env.DEPLOY_PORT == '8080' ? '9090' : '8080')
                    echo "The new deployment will be on port: ${env.NEW_PORT}"
                }
            }
        }

        stage('Git Clone on EC2') {
            steps {
                sshagent(['aws_d']) {
                    withCredentials([usernamePassword(credentialsId: 'gitlab', passwordVariable: 'GITLAB_TOKEN', usernameVariable: 'GITLAB_USER')]) {
                        script {
                            sh '''
                            ENCODED_USER=$(echo $GITLAB_USER | sed 's/@/%40/g')
                            ssh -o StrictHostKeyChecking=no ubuntu@k10e102.p.ssafy.io "
                                rm -rf ~/backend
                                git clone -b dev_back https://$ENCODED_USER:$GITLAB_TOKEN@lab.ssafy.com/s10-final/S10P31E102.git ~/backend
                            "
                            '''
                        }
                    }
                }
            }
        }

        stage('BE-Build') {
            steps {
                sshagent(['aws_d']) {
                    script {
                        sh '''
                        ssh -o StrictHostKeyChecking=no ubuntu@k10e102.p.ssafy.io "
                            cd ~/backend/backend/bandi
                            chmod +x gradlew
                            ./gradlew clean build -i
                        "
                        '''
                    }
                }
            }
        }

        stage('Docker Build and Push') {
            steps {
                sshagent(['aws_d']) {
                    withCredentials([usernamePassword(credentialsId: 'dockerhub', passwordVariable: 'DOCKER_PASSWORD', usernameVariable: 'DOCKER_USERNAME')]) {
                        script {
                            sh '''
                            ssh -o StrictHostKeyChecking=no ubuntu@k10e102.p.ssafy.io "
                                cd ~/backend/backend/bandi
                                echo ${DOCKER_PASSWORD} | docker login --username ${DOCKER_USERNAME} --password-stdin
                                docker build -t raeljung/banditbul-spring:1.0 .
                                docker push raeljung/banditbul-spring:1.0
                            "
                            '''
                        }
                    }
                }
            }
        }

        stage('BackEnd Deploy to EC2') {
            steps {
                sshagent(['aws_d']) {
                    script {
                        // Jenkins 환경 변수를 Groovy 문자열로 확장
                        def newPort = env.NEW_PORT
                        sh """
                        ssh -o StrictHostKeyChecking=no ubuntu@k10e102.p.ssafy.io '
                            # Docker 관련 명령
                            echo ${newPort}
                            if docker ps -q -f name=back-${newPort}; then
                                docker stop back-${newPort}
                                docker rm back-${newPort}
                                docker rmi raeljung/banditbul-spring:1.0
                            fi
                            docker run -p ${newPort}:8080 -d --name back-${newPort} raeljung/banditbul-spring:1.0
                        '
                        """
                    }
                }
            }
        }

        stage('Update Nginx Configuration and Reload') {
            steps {
                sshagent(['aws']) {
                    script {
                        sh """
                        ssh -o StrictHostKeyChecking=no ubuntu@banditbul.co.kr '
                            # 기존 설정 파일 제거
                            sudo rm -f /etc/nginx/sites-enabled/default
                            # 포트 번호 변경
                            sudo sed -i "s/set \\\$port [0-9]\\+;/set \\\$port ${env.NEW_PORT};/" /etc/nginx/conf.d/include/port.conf
                            # 변경된 포트 번호를 환경 변수로 설정
                            export port=${env.NEW_PORT}
                            # 변경된 환경 변수를 사용하여 Nginx 설정을 업데이트
                            sudo -E envsubst \\\${port} < /etc/nginx/conf.d/include/default.template | sudo tee /etc/nginx/sites-enabled/default > /dev/null
                            # Nginx 구성 검사
                            sudo nginx -t && sudo nginx -s reload
                        '
                        """
                    }
                }
            }
        }
    }
}

```

### Front
```
pipeline {
    agent any
    options { skipDefaultCheckout(false) }
    tools {
        nodejs 'NodeJS' //NodeJS Tool에서 지정한 NodeJs 이름
    }
    stages {
            stage('Git Clone') {
                steps {
                    git branch: 'dev_web', credentialsId: 'gitlab', url: 'https://lab.ssafy.com/s10-final/S10P31E102'
                }
            }
            stage('FE-Build') {
                steps {
                    dir("./frontend/web"){
                        nodejs(nodeJSInstallationName: 'NodeJS'){
                            //CI: 오류 무시
                            sh 'npm install'
                            sh 'CI=false npm run build'
                        }
                    }
                }
            }
            
            stage('Compression'){
                steps{
                    dir("./frontend/web"){
                        sh '''
                        rm -rf node_modules
                        tar -cvf build.tar dist
                        '''
                    }
                }
            }
            
            stage('Deploy to EC2'){
                steps {
                    // EC2 서버에 SSH 접속 크레덴셜 ID
                    sshagent(credentials: ['aws']) {
                        sh '''
                            ssh -o StrictHostKeyChecking=no ubuntu@43.201.129.148 uptime
                            scp /var/jenkins_home/workspace/fe_web/frontend/web/build.tar ubuntu@43.201.129.148:/home/ubuntu
                            ssh -t ubuntu@43.201.129.148 "chmod +x /home/ubuntu/deploy.sh && /home/ubuntu/deploy.sh"
                        '''
                    }
                }
            }
    }
}
```

## 배포 환경 
최종 배포 환경이 아래와 같도록 세팅합니다. 
  
```
$ docker ps 
```

### 서버 M

### 서버 D

### 서버 T
